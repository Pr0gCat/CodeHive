import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { taskManager } from '@/lib/tasks/task-manager';
import { gitClient } from '@/lib/git';
import { z } from 'zod';
import { promises as fs } from 'fs';
import path from 'path';

const createProjectSchema = z.object({
  name: z.string().min(1, 'Project name is required'),
  description: z.string().optional(),
  gitUrl: z.string().url().optional(),
  localPath: z.string().optional(),
  initializeGit: z.boolean().default(true),
  taskId: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validatedData = createProjectSchema.parse(body);
    const { name, description, gitUrl, initializeGit, taskId } = validatedData;
    
    // Generate localPath if not provided
    const localPath = validatedData.localPath?.trim() || gitClient.generateProjectPath(name);
    
    // Check if project already exists
    const existingProject = await prisma.project.findFirst({
      where: { name },
    });

    if (existingProject) {
      return NextResponse.json(
        {
          success: false,
          error: 'A project with this name already exists',
        },
        { status: 409 }
      );
    }

    // Define phases for project creation
    const phases = [
      { phaseId: 'validation', title: 'È©óË≠âÂ∞àÊ°àË≥áË®ä', description: 'Ê™¢Êü•Â∞àÊ°àÂêçÁ®±ÂíåË∑ØÂæë', order: 0 },
      { phaseId: 'setup', title: 'Âª∫Á´ãÂ∞àÊ°àÁµêÊßã', description: 'Âª∫Á´ãÂ∞àÊ°àÁõÆÈåÑÂíåÂàùÂßãÊ™îÊ°à', order: 1 },
      { phaseId: 'git_init', title: 'ÂàùÂßãÂåñ Git', description: 'Âª∫Á´ã Git ÂÑ≤Â≠òÂ∫´ÂíåÂàùÂßãÊèê‰∫§', order: 2 },
      { phaseId: 'claude_md_generation', title: 'ÁîüÊàê CLAUDE.md', description: '‰ΩøÁî® Claude Code ÁîüÊàêÂ∞àÊ°àÊåáÂçó', order: 3 },
      { phaseId: 'analysis', title: 'ÂàÜÊûêÂ∞àÊ°à', description: 'ÊéÉÊèèÊäÄË°ìÂ†ÜÁñäÂíåÂ∞àÊ°àÁµêÊßã', order: 4 },
      { phaseId: 'completion', title: 'ÂÆåÊàêË®≠ÂÆö', description: 'ÂÑ≤Â≠òÂ∞àÊ°àË≥áË®äÂà∞Ë≥áÊñôÂ∫´', order: 5 },
    ];

    // Create task for project creation
    const taskIdToUse = taskId || `create-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    await taskManager.createTask(taskIdToUse, 'PROJECT_CREATE', phases, {
      projectName: name,
      // Don't set projectId until project is created
    });

    // Start the task
    await taskManager.startTask(taskIdToUse);

    // Start async project creation
    createProjectAsync(taskIdToUse, {
      name,
      description,
      gitUrl,
      localPath,
      initializeGit,
    }).catch(async (error) => {
      console.error('Project creation failed:', error);
      await taskManager.updatePhaseProgress(taskIdToUse, 'complete', 100, {
        type: 'ERROR',
        message: `Project creation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      });
    });

    return NextResponse.json({
      success: true,
      data: {
        taskId: taskIdToUse,
        message: 'Project creation started',
      },
    });
  } catch (error) {
    console.error('Error creating project:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid project data',
          details: error.issues,
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      {
        success: false,
        error: 'Failed to create project',
      },
      { status: 500 }
    );
  }
}

/**
 * Create a basic CLAUDE.md file with provided context as fallback
 */
async function createBasicClaudeMd(
  projectPath: string,
  projectName: string,
  projectDescription: string,
  gitUrl?: string
): Promise<void> {
  const claudeMdContent = `# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**${projectName}**

${projectDescription}

${gitUrl ? `**Repository**: ${gitUrl}` : ''}

## Getting Started

This is a newly created project. To get started:

1. Set up your development environment
2. Install any necessary dependencies
3. Review the project structure
4. Begin development according to your project requirements

## Development Guidelines

1. **Code Quality**: Maintain consistent code style and formatting
2. **Documentation**: Keep README and inline documentation up to date
3. **Version Control**: Make regular commits with clear messages
4. **Testing**: Add tests for new functionality as the project grows

## Project Structure

This project follows a standard structure. Organize your code logically and maintain clean separation of concerns.

## Working with This Project

When making changes to this codebase:

1. Follow consistent naming conventions
2. Add appropriate documentation for new features
3. Test your changes before committing
4. Keep the project structure clean and organized

---

*This CLAUDE.md was generated by CodeHive Project Manager on ${new Date().toISOString().split('T')[0]}*
`;

  const claudeMdPath = path.join(projectPath, 'CLAUDE.md');
  await fs.writeFile(claudeMdPath, claudeMdContent, 'utf8');
  console.log(`üìù Created basic CLAUDE.md at ${claudeMdPath}`);
}

async function createProjectAsync(
  taskId: string,
  data: {
    name: string;
    description?: string;
    gitUrl?: string;
    localPath: string;
    initializeGit: boolean;
  }
) {
  const { name, description, gitUrl, localPath, initializeGit } = data;

  try {
    // Phase 1: Validation
    const validationPhaseId = 'validation';
    await taskManager.updatePhaseProgress(taskId, validationPhaseId, 0, {
      type: 'PHASE_START',
      message: 'Starting validation',
    });

    // Check project name availability
    await taskManager.updatePhaseProgress(taskId, validationPhaseId, 30, {
      type: 'PHASE_PROGRESS',
      message: 'Checking project name availability',
    });

    // Ensure directory exists
    await fs.mkdir(path.dirname(localPath), { recursive: true });
    
    await taskManager.updatePhaseProgress(taskId, validationPhaseId, 70, {
      type: 'PHASE_PROGRESS',
      message: 'Validating project path',
    });
    
    await taskManager.updatePhaseProgress(taskId, validationPhaseId, 100, {
      type: 'PHASE_COMPLETE',
      message: 'Validation completed',
    });

    // Phase 2: Setup
    const setupPhaseId = 'setup';
    await taskManager.updatePhaseProgress(taskId, setupPhaseId, 0, {
      type: 'PHASE_START',
      message: 'Creating project structure',
    });

    await taskManager.updatePhaseProgress(taskId, setupPhaseId, 20, {
      type: 'PHASE_PROGRESS',
      message: 'Creating project directory',
    });

    // Create project directory
    await fs.mkdir(localPath, { recursive: true });
    
    await taskManager.updatePhaseProgress(taskId, setupPhaseId, 50, {
      type: 'PHASE_PROGRESS',
      message: 'Generating README.md',
    });
    
    // Create README
    const readmePath = path.join(localPath, 'README.md');
    const readmeContent = `# ${name}

${description || 'A CodeHive managed project'}

## Getting Started

This project is managed by CodeHive using AI-Native TDD development.

### Project Information
- **Created**: ${new Date().toISOString()}
- **Type**: ${gitUrl ? 'Imported from Git' : 'New Project'}
${gitUrl ? `- **Repository**: ${gitUrl}` : ''}

### Development Workflow
1. Create feature requests through CodeHive UI
2. Project Manager agent breaks down features into Epics and Stories
3. TDD cycles drive development with minimal manual intervention
4. All changes are tracked through Git commits
`;

    await fs.writeFile(readmePath, readmeContent, 'utf8');
    
    await taskManager.updatePhaseProgress(taskId, setupPhaseId, 80, {
      type: 'PHASE_PROGRESS',
      message: 'Creating initial project files',
    });
    
    await taskManager.updatePhaseProgress(taskId, setupPhaseId, 100, {
      type: 'PHASE_COMPLETE',
      message: 'Project structure created',
    });

    // Phase 3: Git initialization
    const gitInitPhaseId = 'git_init';
    await taskManager.updatePhaseProgress(taskId, gitInitPhaseId, 0, {
      type: 'PHASE_START',
      message: 'Initializing Git repository',
    });

    if (initializeGit) {
      const isExistingRepo = await gitClient.isValidRepository(localPath);
      
      if (!isExistingRepo) {
        const initResult = await gitClient.init(localPath);
        
        if (!initResult.success) {
          throw new Error(`Failed to initialize Git: ${initResult.error}`);
        }

        // Create initial commit
        const commitResult = await gitClient.initialCommit(
          localPath,
          'Initial commit - CodeHive project setup'
        );
        
        if (!commitResult.success) {
          console.warn('Failed to create initial commit:', commitResult.error);
        }
      }
    }

    await taskManager.updatePhaseProgress(taskId, gitInitPhaseId, 100, {
      type: 'PHASE_COMPLETE',
      message: 'Git repository initialized',
    });

    // Phase 4: Generate CLAUDE.md
    const claudeMdPhaseId = 'claude_md_generation';
    await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 0, {
      type: 'PHASE_START',
      message: 'Generating CLAUDE.md with Claude Code',
    });

    try {
      // Check if we have a description - if not, this might be importing an existing project
      const isImportingExisting = !description || description.trim() === '';
      
      if (isImportingExisting) {
        // For importing existing projects, use /init to analyze the existing codebase
        const { claudeCode } = await import('@/lib/claude-code');
        
        const claudeResult = await claudeCode.execute('/init', {
          workingDirectory: localPath,
          timeout: 180000, // 3 minutes
        });

        if (claudeResult.success) {
          console.log(`‚úÖ CLAUDE.md generated successfully using Claude Code /init`);
          await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 100, {
            type: 'PHASE_COMPLETE',
            message: 'CLAUDE.md ÁîüÊàêÊàêÂäü',
          });
        } else {
          console.log(`‚ö†Ô∏è Claude Code /init failed: ${claudeResult.error}`);
          // Skip CLAUDE.md generation for imported projects if /init fails
          await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 100, {
            type: 'PHASE_COMPLETE',
            message: 'CLAUDE.md ÁîüÊàêË∑≥ÈÅé',
          });
        }
      } else {
        // For new projects with description, provide context to Claude Code
        const { claudeCode } = await import('@/lib/claude-code');
        
        const projectContext = `
Project Name: ${name}
Project Description: ${description}
${gitUrl ? `Git URL: ${gitUrl}` : ''}
Project Path: ${localPath}

This is a newly created project. Please create a comprehensive CLAUDE.md file that includes:
1. Project overview based on the provided description
2. Basic project structure guidelines
3. Development setup instructions
4. Best practices and conventions to follow
5. Common workflows for this type of project

Please create the CLAUDE.md file in the current directory.
`.trim();

        const claudeResult = await claudeCode.execute(projectContext, {
          workingDirectory: localPath,
          timeout: 180000, // 3 minutes
        });

        if (claudeResult.success) {
          console.log(`‚úÖ CLAUDE.md generated successfully using Claude Code`);
          await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 100, {
            type: 'PHASE_COMPLETE',
            message: 'CLAUDE.md ÁîüÊàêÊàêÂäü',
          });
        } else {
          console.log(`‚ö†Ô∏è Claude Code generation failed: ${claudeResult.error}`);
          // Fallback: create a basic CLAUDE.md with provided context
          await createBasicClaudeMd(localPath, name, description, gitUrl);
          await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 100, {
            type: 'PHASE_COMPLETE',
            message: 'CLAUDE.md ‰ΩøÁî®Âü∫Êú¨Ê®°ÊùøÁîüÊàê',
          });
        }
      }
    } catch (claudeMdError) {
      console.error(`‚ùå Error generating CLAUDE.md:`, claudeMdError);
      
      // Only create fallback CLAUDE.md if we have a description (new project)
      if (description && description.trim() !== '') {
        try {
          await createBasicClaudeMd(localPath, name, description, gitUrl);
          await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 100, {
            type: 'PHASE_COMPLETE',
            message: 'CLAUDE.md ‰ΩøÁî®Âü∫Êú¨Ê®°ÊùøÁîüÊàêÔºàÂõûÈÄÄÔºâ',
          });
        } catch (fallbackError) {
          await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 100, {
            type: 'PHASE_COMPLETE',
            message: `CLAUDE.md ÁîüÊàêÂ§±Êïó: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`,
          });
        }
      } else {
        // For imported projects without description, skip CLAUDE.md generation
        await taskManager.updatePhaseProgress(taskId, claudeMdPhaseId, 100, {
          type: 'PHASE_COMPLETE',
          message: 'CLAUDE.md ÁîüÊàêË∑≥ÈÅéÔºàÂåØÂÖ•ÁèæÊúâÂ∞àÊ°àÔºâ',
        });
      }
    }

    // Phase 5: Analysis
    const analysisPhaseId = 'analysis';
    await taskManager.updatePhaseProgress(taskId, analysisPhaseId, 0, {
      type: 'PHASE_START',
      message: 'Analyzing project structure',
    });

    // Run project analysis (detect tech stack, etc.)
    // This is simplified for now
    await taskManager.updatePhaseProgress(taskId, analysisPhaseId, 100, {
      type: 'PHASE_COMPLETE',
      message: 'Analysis completed',
    });

    // Phase 6: Create project in database first (needed for description generation)
    const completionPhaseId = 'completion';
    await taskManager.updatePhaseProgress(taskId, completionPhaseId, 0, {
      type: 'PHASE_START',
      message: 'Creating project record',
    });

    // Create project in database
    const project = await prisma.project.create({
      data: {
        name,
        description,
        gitUrl,
        localPath,
        status: 'ACTIVE',
      },
    });

    await taskManager.updatePhaseProgress(taskId, completionPhaseId, 30, {
      type: 'PHASE_PROGRESS',
      message: 'Project record created',
    });

    // Generate intelligent project description using Claude Code
    let finalDescription = description || 'Software project';
    try {
      console.log(`ü§ñ Generating project description using Claude Code for: ${project.name}...`);

      await taskManager.updatePhaseProgress(taskId, completionPhaseId, 50, {
        type: 'PHASE_PROGRESS',
        message: '‰ΩøÁî® Claude Code ÂàÜÊûêÂ∞àÊ°à',
      });

      const descriptionResponse = await fetch(
        `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/agents/project-manager`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            projectId: project.id,
            action: 'analyze',
          }),
        }
      );

      const descriptionResult = await descriptionResponse.json();
      if (descriptionResult.success && descriptionResult.data?.context) {
        const summaryResponse = await fetch(
          `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/agents/project-manager`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              projectId: project.id,
              action: 'generate-summary',
              context: descriptionResult.data.context,
            }),
          }
        );

        const summaryResult = await summaryResponse.json();
        if (summaryResult.success && summaryResult.data?.summary) {
          finalDescription = summaryResult.data.summary;
          console.log(`‚úÖ Generated intelligent description: "${finalDescription}"`);
        }
      }
    } catch (descriptionError) {
      console.error(`‚ö†Ô∏è Failed to generate project description for ${project.name}:`, descriptionError);
      // Continue with default description
    }

    await taskManager.updatePhaseProgress(taskId, completionPhaseId, 70, {
      type: 'PHASE_PROGRESS',
      message: 'Êõ¥Êñ∞Â∞àÊ°àÊèèËø∞',
    });

    // Update project with generated description
    if (finalDescription !== project.description) {
      await prisma.project.update({
        where: { id: project.id },
        data: { description: finalDescription },
      });
    }

    await taskManager.updatePhaseProgress(taskId, completionPhaseId, 100, {
      type: 'PHASE_COMPLETE',
      message: 'Project setup completed',
    });

    // Complete the task
    await taskManager.completeTask(taskId, {
      project: {
        id: project.id,
        name: project.name,
        localPath: project.localPath,
      },
    });

  } catch (error) {
    console.error('Error in createProjectAsync:', error);
    await taskManager.updatePhaseProgress(taskId, 'complete', 100, {
      type: 'ERROR',
      message: `Project creation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
    });
    throw error;
  }
}